from cassandra.cluster import Cluster
from cassandra.auth import PlainTextAuthProvider
from flask import Flask, request, jsonify
from flask_cors import CORS
from langchain_community.chat_message_histories import CassandraChatMessageHistory
from langchain.prompts import PromptTemplate
from langchain_openai import OpenAI
from langchain.memory import ConversationBufferMemory
from langchain_core.output_parsers import StrOutputParser
import json

app = Flask(__name__)
CORS(app)

# Load secrets
with open("choice-game-token.json") as f:
    secrets = json.load(f)

# Cassandra and OpenAI configuration
cloud_config = {
    'secure_connect_bundle': 'secure-connect-choice-game.zip'
}
CLIENT_ID = secrets["clientId"]
CLIENT_SECRET = secrets["secret"]
ASTRA_DB_KEYSPACE = "choice"
OPENAI_API_KEY = "sk-proj-3EgJJ000nZ6N2yomnXWFT3BlbkFJAuvMz8n8OSldJHwHSICb"

auth_provider = PlainTextAuthProvider(CLIENT_ID, CLIENT_SECRET)
cluster = Cluster(cloud=cloud_config, auth_provider=auth_provider)
session = cluster.connect()

# Initialize message history
message_history = CassandraChatMessageHistory(
    session_id="choice_session",
    session=session,
    keyspace=ASTRA_DB_KEYSPACE,
    ttl_seconds=3600
)

template = """
You are an AI storyteller creating an immersive, unique, and challenging text-based game. The story follows a man who wakes up to find himself alone at home and decides to uncover what happened to his family. In the darkness, everything looks different and potentially dangerous.

Rules and guidelines:
1. Create a rich, atmospheric narrative with detailed descriptions of the environment, sounds, smells, and the protagonist's emotions.
2. Introduce complex moral choices and dilemmas that have significant consequences on the story's progression.
3. Implement a subtle system of cause and effect, where earlier choices impact later scenarios.
4. Include various paths to success, but make them challenging to achieve. Not every path should lead to a positive outcome.
5. Introduce elements of mystery, suspense, and occasional age-appropriate horror to keep the player engaged.
6. Do not be repetitive. Find a good balance between intense and calm scenes.
7. After each narrative segment, present the player with four options:
    A, B, and C should be specific choices generated by you, each with potential good or bad outcomes.
    D should always be phrased as "Your "CHOICE" (specify your action)".
8. If you believe that the player's decision is not optimal, then be sure there is appropriate consequences.
9. If the player makes a decision that leads to a critical failure or death, explain the consequences and end with "The End."
10. If the user asks for clarification, provide a brief, clear answer without advancing the story.

Remember: Do not generate user responses. Always wait for actual user input.

Chat history: {chat_history}
User: {user_input}

AI: If the user input ends with a question mark, provide a brief, clear answer without advancing the story. Otherwise, respond to the user's input with a detailed, immersive continuation of the story, following the guidelines above.
"""

# Create the prompt
prompt = PromptTemplate(
    input_variables=["chat_history", "user_input"],
    template=template
)

# Initialize the LLM with the API key
llm = OpenAI(openai_api_key=OPENAI_API_KEY, max_tokens = 500)

def initialize_game():
    global chain, cass_buff_memory
    message_history.clear()
    cass_buff_memory = ConversationBufferMemory(
        memory_key="chat_history",
        chat_memory=message_history
    )
    chain = prompt | llm | StrOutputParser()

@app.route('/start_game', methods=['GET'])
def start_game():
    initialize_game()
    response = chain.invoke({"chat_history": "", "user_input": "Start the game by asking the player to choose a weapon."})
    return jsonify({"response": response.strip()})

@app.route('/send_message', methods=['POST'])
def send_message():
    initialize_game()
    choice = request.json['message']
    memory_variables = cass_buff_memory.load_memory_variables({})
    response = chain.invoke({"chat_history": memory_variables["chat_history"], "user_input": choice})
    cass_buff_memory.save_context({"input": choice}, {"output": response})
    return jsonify({"response": response.strip()})

if __name__ == '__main__':
    app.run(port=5000)
